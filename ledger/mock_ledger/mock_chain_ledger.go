// Code generated by MockGen. DO NOT EDIT.
// Source: chain_ledger.go
//
// Generated by this command:
//
//	mockgen -destination mock_ledger/mock_chain_ledger.go -package mock_ledger -source chain_ledger.go -typed
//
// Package mock_ledger is a generated GoMock package.
package mock_ledger

import (
	reflect "reflect"

	types "github.com/axiomesh/axiom-kit/types"
	gomock "go.uber.org/mock/gomock"
)

// MockChainLedger is a mock of ChainLedger interface.
type MockChainLedger struct {
	ctrl     *gomock.Controller
	recorder *MockChainLedgerMockRecorder
}

// MockChainLedgerMockRecorder is the mock recorder for MockChainLedger.
type MockChainLedgerMockRecorder struct {
	mock *MockChainLedger
}

// NewMockChainLedger creates a new mock instance.
func NewMockChainLedger(ctrl *gomock.Controller) *MockChainLedger {
	mock := &MockChainLedger{ctrl: ctrl}
	mock.recorder = &MockChainLedgerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChainLedger) EXPECT() *MockChainLedgerMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockChainLedger) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockChainLedgerMockRecorder) Close() *ChainLedgerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockChainLedger)(nil).Close))
	return &ChainLedgerCloseCall{Call: call}
}

// ChainLedgerCloseCall wrap *gomock.Call
type ChainLedgerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerCloseCall) Return() *ChainLedgerCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerCloseCall) Do(f func()) *ChainLedgerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerCloseCall) DoAndReturn(f func()) *ChainLedgerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlock mocks base method.
func (m *MockChainLedger) GetBlock(height uint64) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlock", height)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlock indicates an expected call of GetBlock.
func (mr *MockChainLedgerMockRecorder) GetBlock(height any) *ChainLedgerGetBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlock", reflect.TypeOf((*MockChainLedger)(nil).GetBlock), height)
	return &ChainLedgerGetBlockCall{Call: call}
}

// ChainLedgerGetBlockCall wrap *gomock.Call
type ChainLedgerGetBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockCall) Return(arg0 *types.Block, arg1 error) *ChainLedgerGetBlockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockCall) Do(f func(uint64) (*types.Block, error)) *ChainLedgerGetBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockCall) DoAndReturn(f func(uint64) (*types.Block, error)) *ChainLedgerGetBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockByHash mocks base method.
func (m *MockChainLedger) GetBlockByHash(hash *types.Hash) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockByHash", hash)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockByHash indicates an expected call of GetBlockByHash.
func (mr *MockChainLedgerMockRecorder) GetBlockByHash(hash any) *ChainLedgerGetBlockByHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockByHash", reflect.TypeOf((*MockChainLedger)(nil).GetBlockByHash), hash)
	return &ChainLedgerGetBlockByHashCall{Call: call}
}

// ChainLedgerGetBlockByHashCall wrap *gomock.Call
type ChainLedgerGetBlockByHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockByHashCall) Return(arg0 *types.Block, arg1 error) *ChainLedgerGetBlockByHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockByHashCall) Do(f func(*types.Hash) (*types.Block, error)) *ChainLedgerGetBlockByHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockByHashCall) DoAndReturn(f func(*types.Hash) (*types.Block, error)) *ChainLedgerGetBlockByHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockHash mocks base method.
func (m *MockChainLedger) GetBlockHash(height uint64) *types.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockHash", height)
	ret0, _ := ret[0].(*types.Hash)
	return ret0
}

// GetBlockHash indicates an expected call of GetBlockHash.
func (mr *MockChainLedgerMockRecorder) GetBlockHash(height any) *ChainLedgerGetBlockHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockHash", reflect.TypeOf((*MockChainLedger)(nil).GetBlockHash), height)
	return &ChainLedgerGetBlockHashCall{Call: call}
}

// ChainLedgerGetBlockHashCall wrap *gomock.Call
type ChainLedgerGetBlockHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockHashCall) Return(arg0 *types.Hash) *ChainLedgerGetBlockHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockHashCall) Do(f func(uint64) *types.Hash) *ChainLedgerGetBlockHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockHashCall) DoAndReturn(f func(uint64) *types.Hash) *ChainLedgerGetBlockHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockSign mocks base method.
func (m *MockChainLedger) GetBlockSign(height uint64) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockSign", height)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockSign indicates an expected call of GetBlockSign.
func (mr *MockChainLedgerMockRecorder) GetBlockSign(height any) *ChainLedgerGetBlockSignCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockSign", reflect.TypeOf((*MockChainLedger)(nil).GetBlockSign), height)
	return &ChainLedgerGetBlockSignCall{Call: call}
}

// ChainLedgerGetBlockSignCall wrap *gomock.Call
type ChainLedgerGetBlockSignCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockSignCall) Return(arg0 []byte, arg1 error) *ChainLedgerGetBlockSignCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockSignCall) Do(f func(uint64) ([]byte, error)) *ChainLedgerGetBlockSignCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockSignCall) DoAndReturn(f func(uint64) ([]byte, error)) *ChainLedgerGetBlockSignCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetChainMeta mocks base method.
func (m *MockChainLedger) GetChainMeta() *types.ChainMeta {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetChainMeta")
	ret0, _ := ret[0].(*types.ChainMeta)
	return ret0
}

// GetChainMeta indicates an expected call of GetChainMeta.
func (mr *MockChainLedgerMockRecorder) GetChainMeta() *ChainLedgerGetChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetChainMeta", reflect.TypeOf((*MockChainLedger)(nil).GetChainMeta))
	return &ChainLedgerGetChainMetaCall{Call: call}
}

// ChainLedgerGetChainMetaCall wrap *gomock.Call
type ChainLedgerGetChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetChainMetaCall) Return(arg0 *types.ChainMeta) *ChainLedgerGetChainMetaCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetChainMetaCall) Do(f func() *types.ChainMeta) *ChainLedgerGetChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetChainMetaCall) DoAndReturn(f func() *types.ChainMeta) *ChainLedgerGetChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetReceipt mocks base method.
func (m *MockChainLedger) GetReceipt(hash *types.Hash) (*types.Receipt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetReceipt", hash)
	ret0, _ := ret[0].(*types.Receipt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetReceipt indicates an expected call of GetReceipt.
func (mr *MockChainLedgerMockRecorder) GetReceipt(hash any) *ChainLedgerGetReceiptCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReceipt", reflect.TypeOf((*MockChainLedger)(nil).GetReceipt), hash)
	return &ChainLedgerGetReceiptCall{Call: call}
}

// ChainLedgerGetReceiptCall wrap *gomock.Call
type ChainLedgerGetReceiptCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetReceiptCall) Return(arg0 *types.Receipt, arg1 error) *ChainLedgerGetReceiptCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetReceiptCall) Do(f func(*types.Hash) (*types.Receipt, error)) *ChainLedgerGetReceiptCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetReceiptCall) DoAndReturn(f func(*types.Hash) (*types.Receipt, error)) *ChainLedgerGetReceiptCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransaction mocks base method.
func (m *MockChainLedger) GetTransaction(hash *types.Hash) (*types.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransaction", hash)
	ret0, _ := ret[0].(*types.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransaction indicates an expected call of GetTransaction.
func (mr *MockChainLedgerMockRecorder) GetTransaction(hash any) *ChainLedgerGetTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransaction", reflect.TypeOf((*MockChainLedger)(nil).GetTransaction), hash)
	return &ChainLedgerGetTransactionCall{Call: call}
}

// ChainLedgerGetTransactionCall wrap *gomock.Call
type ChainLedgerGetTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetTransactionCall) Return(arg0 *types.Transaction, arg1 error) *ChainLedgerGetTransactionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetTransactionCall) Do(f func(*types.Hash) (*types.Transaction, error)) *ChainLedgerGetTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetTransactionCall) DoAndReturn(f func(*types.Hash) (*types.Transaction, error)) *ChainLedgerGetTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionCount mocks base method.
func (m *MockChainLedger) GetTransactionCount(height uint64) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionCount", height)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionCount indicates an expected call of GetTransactionCount.
func (mr *MockChainLedgerMockRecorder) GetTransactionCount(height any) *ChainLedgerGetTransactionCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionCount", reflect.TypeOf((*MockChainLedger)(nil).GetTransactionCount), height)
	return &ChainLedgerGetTransactionCountCall{Call: call}
}

// ChainLedgerGetTransactionCountCall wrap *gomock.Call
type ChainLedgerGetTransactionCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetTransactionCountCall) Return(arg0 uint64, arg1 error) *ChainLedgerGetTransactionCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetTransactionCountCall) Do(f func(uint64) (uint64, error)) *ChainLedgerGetTransactionCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetTransactionCountCall) DoAndReturn(f func(uint64) (uint64, error)) *ChainLedgerGetTransactionCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionMeta mocks base method.
func (m *MockChainLedger) GetTransactionMeta(hash *types.Hash) (*types.TransactionMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionMeta", hash)
	ret0, _ := ret[0].(*types.TransactionMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionMeta indicates an expected call of GetTransactionMeta.
func (mr *MockChainLedgerMockRecorder) GetTransactionMeta(hash any) *ChainLedgerGetTransactionMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionMeta", reflect.TypeOf((*MockChainLedger)(nil).GetTransactionMeta), hash)
	return &ChainLedgerGetTransactionMetaCall{Call: call}
}

// ChainLedgerGetTransactionMetaCall wrap *gomock.Call
type ChainLedgerGetTransactionMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetTransactionMetaCall) Return(arg0 *types.TransactionMeta, arg1 error) *ChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetTransactionMetaCall) Do(f func(*types.Hash) (*types.TransactionMeta, error)) *ChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetTransactionMetaCall) DoAndReturn(f func(*types.Hash) (*types.TransactionMeta, error)) *ChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LoadChainMeta mocks base method.
func (m *MockChainLedger) LoadChainMeta() (*types.ChainMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadChainMeta")
	ret0, _ := ret[0].(*types.ChainMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadChainMeta indicates an expected call of LoadChainMeta.
func (mr *MockChainLedgerMockRecorder) LoadChainMeta() *ChainLedgerLoadChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadChainMeta", reflect.TypeOf((*MockChainLedger)(nil).LoadChainMeta))
	return &ChainLedgerLoadChainMetaCall{Call: call}
}

// ChainLedgerLoadChainMetaCall wrap *gomock.Call
type ChainLedgerLoadChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerLoadChainMetaCall) Return(arg0 *types.ChainMeta, arg1 error) *ChainLedgerLoadChainMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerLoadChainMetaCall) Do(f func() (*types.ChainMeta, error)) *ChainLedgerLoadChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerLoadChainMetaCall) DoAndReturn(f func() (*types.ChainMeta, error)) *ChainLedgerLoadChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PersistExecutionResult mocks base method.
func (m *MockChainLedger) PersistExecutionResult(block *types.Block, receipts []*types.Receipt) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PersistExecutionResult", block, receipts)
	ret0, _ := ret[0].(error)
	return ret0
}

// PersistExecutionResult indicates an expected call of PersistExecutionResult.
func (mr *MockChainLedgerMockRecorder) PersistExecutionResult(block, receipts any) *ChainLedgerPersistExecutionResultCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PersistExecutionResult", reflect.TypeOf((*MockChainLedger)(nil).PersistExecutionResult), block, receipts)
	return &ChainLedgerPersistExecutionResultCall{Call: call}
}

// ChainLedgerPersistExecutionResultCall wrap *gomock.Call
type ChainLedgerPersistExecutionResultCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerPersistExecutionResultCall) Return(arg0 error) *ChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerPersistExecutionResultCall) Do(f func(*types.Block, []*types.Receipt) error) *ChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerPersistExecutionResultCall) DoAndReturn(f func(*types.Block, []*types.Receipt) error) *ChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackBlockChain mocks base method.
func (m *MockChainLedger) RollbackBlockChain(height uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackBlockChain", height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackBlockChain indicates an expected call of RollbackBlockChain.
func (mr *MockChainLedgerMockRecorder) RollbackBlockChain(height any) *ChainLedgerRollbackBlockChainCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackBlockChain", reflect.TypeOf((*MockChainLedger)(nil).RollbackBlockChain), height)
	return &ChainLedgerRollbackBlockChainCall{Call: call}
}

// ChainLedgerRollbackBlockChainCall wrap *gomock.Call
type ChainLedgerRollbackBlockChainCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerRollbackBlockChainCall) Return(arg0 error) *ChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerRollbackBlockChainCall) Do(f func(uint64) error) *ChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerRollbackBlockChainCall) DoAndReturn(f func(uint64) error) *ChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateChainMeta mocks base method.
func (m *MockChainLedger) UpdateChainMeta(arg0 *types.ChainMeta) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateChainMeta", arg0)
}

// UpdateChainMeta indicates an expected call of UpdateChainMeta.
func (mr *MockChainLedgerMockRecorder) UpdateChainMeta(arg0 any) *ChainLedgerUpdateChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChainMeta", reflect.TypeOf((*MockChainLedger)(nil).UpdateChainMeta), arg0)
	return &ChainLedgerUpdateChainMetaCall{Call: call}
}

// ChainLedgerUpdateChainMetaCall wrap *gomock.Call
type ChainLedgerUpdateChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerUpdateChainMetaCall) Return() *ChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerUpdateChainMetaCall) Do(f func(*types.ChainMeta)) *ChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerUpdateChainMetaCall) DoAndReturn(f func(*types.ChainMeta)) *ChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
